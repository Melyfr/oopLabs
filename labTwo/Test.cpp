#include "Complex.h"

int main() {
	setlocale(0, "rus");

	Complex com1(14, 5);
	Complex com2(4, 5);
	Complex res(18, 10);

	res.setRe(31);
	res.setIm(90);
	assert(com1 * com2 == res); // Тест перегруженного оператора умножения комплексных чисел пройден

	com2.setRe(2);
	com2.setIm(10);
	res.setRe(0.75);
	res.setIm(-1.25);
	assert(com1 / com2 == res); // Тест перегруженного оператора деления комплексных чисел пройден

	com2.setRe(0);
	com2.setIm(0);
	res.setRe(0);
	res.setIm(0);
	assert(com1 / com2 == res); // В случае деления на 0 записывает во все поля комплексного числа 0, чтобы избежать ошибки, тест пройден

	com1.setRe(5);
	com1.setIm(5);
	com2.setRe(5);
	com2.setIm(5);
	assert(com1 == com2 == true); // Тест перегруженного оператора = комплексных чисел пройден

	com1.setRe(6);
	com1.setIm(6);
	com2.setRe(5);
	com2.setIm(5);
	assert(com1 != com2 == true); // Тест перегруженного оператора != комплексных чисел пройден

	assert(com1 > com2 == true); // Тест перегруженного оператора > комплексных чисел пройден

	assert(com2 < com1 == true); // Тест перегруженного оператора < комплексных чисел пройден

	assert(com1 >= com2 == true); // Тест перегруженного оператора >= (случай, когда >) комплексных чисел пройден

	assert(com2 <= com1 == true); // Тест перегруженного оператора <= (случай, когда <)комплексных чисел пройден

	com1.setRe(5);
	com1.setIm(5);
	com2.setRe(5);
	com2.setIm(5);
	assert(com1 >= com2 == true); // Тест перегруженного оператора >= (случай, когда =) комплексных чисел пройден

	assert(com2 <= com1 == true); // Тест перегруженного оператора <= (случай, когда =)комплексных чисел пройден

	cout << "Все тесты пройдены успешно";

	cin.get();
	cin.get();
}
